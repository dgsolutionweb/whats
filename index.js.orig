const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const path = require('path');
const ytDlp = require('yt-dlp-exec');
const { Groq } = require('groq-sdk');
const { MercadoPagoConfig, Payment } = require('mercadopago');
require('dotenv').config();

// Definir ambiente de desenvolvimento se n√£o estiver configurado
process.env.NODE_ENV = process.env.NODE_ENV || 'development';
console.log(`Ambiente: ${process.env.NODE_ENV}`);

// Configura√ß√£o do cliente Groq
const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY,
});

// Configura√ß√£o do Mercado Pago
const mercadopagoClient = new MercadoPagoConfig({
  accessToken: process.env.MERCADOPAGO_ACCESS_TOKEN
});
const paymentClient = new Payment(mercadopagoClient);

// Configura√ß√£o do cliente WhatsApp
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    args: ['--no-sandbox'],
  }
});

// Pasta para os arquivos tempor√°rios
const tempDir = path.join(__dirname, 'temp');
if (!fs.existsSync(tempDir)) {
  fs.mkdirSync(tempDir);
}

// Pasta para armazenar dados
const dataDir = path.join(__dirname, 'data');
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir);
}

// Arquivo de dados para assinaturas e estat√≠sticas
const subscriptionsFile = path.join(dataDir, 'subscriptions.json');
const statsFile = path.join(dataDir, 'stats.json');
const paymentsFile = path.join(dataDir, 'payments.json');

// Limites e configura√ß√µes
const MAX_FILE_SIZE_MB = 15; // Tamanho m√°ximo em MB que o WhatsApp suporta
const MAX_PLAYLIST_ITEMS = 5; // N√∫mero m√°ximo de v√≠deos em uma playlist
const SUBSCRIPTION_PRICE = 10; // Pre√ßo da assinatura mensal em reais

// Estat√≠sticas de uso
const stats = {
  totalConversions: 0,
  totalUsers: new Set(),
  userUsage: {},
  errors: 0,
  lastError: null,
  dailyUsage: {},
  payments: {
    total: 0,
    successful: 0,
    failed: 0
  }
};

// Sistema de assinaturas
const subscriptions = {};

// Sistema de pagamentos pendentes
const pendingPayments = {};

// N√∫meros de administradores do bot
const adminNumbers = process.env.ADMIN_NUMBERS ? process.env.ADMIN_NUMBERS.split(',').map(num => normalizePhoneNumber(num)) : [];

// Fun√ß√£o para normalizar n√∫meros de telefone
function normalizePhoneNumber(phone) {
  // Remove qualquer caractere que n√£o seja d√≠gito
  let normalized = phone.replace(/\D/g, '');
  
  // Se for um n√∫mero completo com c√≥digo do pa√≠s, garante que esteja sem o "+" inicial
  if (normalized.startsWith('55')) {
    return normalized;
  }
  
  // Adiciona c√≥digo do Brasil se n√£o estiver presente
  if (!normalized.startsWith('55')) {
    normalized = '55' + normalized;
  }
  
  return normalized;
}

// Fun√ß√£o para verificar se o usu√°rio tem assinatura ativa
function hasActiveSubscription(userId) {
  if (!subscriptions[userId]) {
    return false;
  }
  
  const today = new Date();
  const expiryDate = new Date(subscriptions[userId].expiresAt);
  
  if (today > expiryDate) {
    // Assinatura expirada
    delete subscriptions[userId];
    return false;
  }
  
  return true;
}

// Carregar dados salvos
function loadSavedData() {
  try {
    // Carregar assinaturas
    if (fs.existsSync(subscriptionsFile)) {
      const data = fs.readFileSync(subscriptionsFile, 'utf8');
      Object.assign(subscriptions, JSON.parse(data));
      console.log(`Carregadas ${Object.keys(subscriptions).length} assinaturas do arquivo`);
    }
    
    // Carregar estat√≠sticas
    if (fs.existsSync(statsFile)) {
      const data = fs.readFileSync(statsFile, 'utf8');
      const loadedStats = JSON.parse(data);
      
      // Restaurar propriedades primitivas
      stats.totalConversions = loadedStats.totalConversions || 0;
      stats.errors = loadedStats.errors || 0;
      stats.lastError = loadedStats.lastError || null;
      
      // Restaurar totalUsers como Set
      stats.totalUsers = new Set(loadedStats.totalUsers || []);
      
      // Restaurar outras propriedades
      stats.userUsage = loadedStats.userUsage || {};
      stats.dailyUsage = loadedStats.dailyUsage || {};
      stats.payments = loadedStats.payments || { total: 0, successful: 0, failed: 0 };
      
      console.log('Estat√≠sticas carregadas do arquivo');
    }
    
    // Carregar pagamentos pendentes
    if (fs.existsSync(paymentsFile)) {
      const data = fs.readFileSync(paymentsFile, 'utf8');
      const loadedPayments = JSON.parse(data);
      
      // Converter strings de data de volta para objetos Date
      for (const userId in loadedPayments) {
        if (loadedPayments[userId].created_at) {
          loadedPayments[userId].created_at = new Date(loadedPayments[userId].created_at);
        }
      }
      
      Object.assign(pendingPayments, loadedPayments);
      console.log(`Carregados ${Object.keys(pendingPayments).length} pagamentos pendentes do arquivo`);
    }
  } catch (error) {
    console.error('Erro ao carregar dados salvos:', error);
  }
}

// Salvar dados periodicamente
function saveData() {
  try {
    // Salvar assinaturas
    fs.writeFileSync(subscriptionsFile, JSON.stringify(subscriptions, null, 2));
    
    // Preparar estat√≠sticas para salvar (converter Set para Array)
    const statsToSave = {
      ...stats,
      totalUsers: Array.from(stats.totalUsers)
    };
    
    // Salvar estat√≠sticas
    fs.writeFileSync(statsFile, JSON.stringify(statsToSave, null, 2));
    
    // Salvar pagamentos pendentes
    fs.writeFileSync(paymentsFile, JSON.stringify(pendingPayments, null, 2));
    
    console.log('Dados salvos com sucesso');
  } catch (error) {
    console.error('Erro ao salvar dados:', error);
  }
}

// Carregar dados ao iniciar
loadSavedData();

// Salvar dados a cada 10 minutos e ao encerrar
setInterval(saveData, 10 * 60 * 1000);
process.on('SIGINT', () => {
  console.log('Salvando dados antes de encerrar...');
  saveData();
  process.exit();
});

// Evento de QR Code
client.on('qr', (qr) => {
  console.log('QR RECEBIDO, escaneie com o WhatsApp!');
  qrcode.generate(qr, { small: true });
});

// Evento de login
client.on('ready', () => {
  console.log('Cliente WhatsApp conectado!');
});

// Fun√ß√£o para verificar se uma URL √© uma playlist
function isPlaylistUrl(url) {
  return url.includes('playlist?list=') || url.includes('&list=');
}

// Fun√ß√£o para extrair o ID da playlist
function extractPlaylistId(url) {
  const regex = /[&?]list=([^&]+)/;
  const match = url.match(regex);
  return match ? match[1] : null;
}

// Fun√ß√£o para obter informa√ß√µes da playlist
async function getPlaylistInfo(url) {
  try {
    const info = await ytDlp(url, {
      flatPlaylist: true,
      dumpSingleJson: true,
      noCheckCertificate: true,
      noWarnings: true,
      preferFreeFormats: true,
      addHeader: [
        'referer:youtube.com',
        'user-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      ]
    });

    // Limitar o n√∫mero de v√≠deos a serem baixados
    info.entries = info.entries.slice(0, MAX_PLAYLIST_ITEMS);
    
    return info;
  } catch (error) {
    console.error('Erro ao obter informa√ß√µes da playlist:', error);
    throw error;
  }
}

// Fun√ß√£o para converter URL do YouTube para MP3 usando yt-dlp
async function convertYoutubeToMp3(url, outputPath) {
  return new Promise((resolve, reject) => {
    const videoId = extractVideoId(url);
    
    // Op√ß√µes melhoradas para o yt-dlp
    ytDlp(url, {
      extractAudio: true,
      audioFormat: 'mp3',
      audioQuality: 0,
      output: outputPath,
      noCheckCertificate: true,
      noWarnings: true,
      preferFreeFormats: true,
      maxFilesize: `${MAX_FILE_SIZE_MB}M`, // Limitar o tamanho do arquivo
      addHeader: [
        'referer:youtube.com',
        'user-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      ],
      progress: true // Habilitar informa√ß√µes de progresso
    })
    .then(() => {
      console.log('Convers√£o finalizada');
      resolve(outputPath);
    })
    .catch((err) => {
      console.error('Erro durante a convers√£o:', err);
      reject(err);
    });
  });
}

// Extrai o ID do v√≠deo da URL
function extractVideoId(url) {
  if (url.includes('youtu.be/')) {
    return url.split('youtu.be/')[1].split('?')[0];
  } else if (url.includes('youtube.com/watch?v=')) {
    return url.split('v=')[1].split('&')[0];
  } else {
    return 'video';
  }
}

// Verificar se a URL √© do YouTube
function isYoutubeUrl(url) {
  return url.includes('youtube.com/') || url.includes('youtu.be/');
}

// Usar Groq para analisar a mensagem e verificar inten√ß√µes
async function analyzeMessage(text) {
  try {
    const completion = await groq.chat.completions.create({
      messages: [
        {
          role: "system",
          content: "Voc√™ √© um assistente descolado e divertido que ajuda a converter v√≠deos do YouTube em MP3. Use uma linguagem jovem, informal e brasileira, com g√≠rias como 'mano', 'cara', 'massa', 'top', 'da hora'. Abrevie palavras como 't√°', 't√¥', 'pra'. Use muitos emojis e seja entusiasmado. \n\n" +
          "Se o texto do usu√°rio mencionar algo sobre converter v√≠deo ou √°udio do YouTube, pe√ßa educadamente que ele envie a URL do v√≠deo. \n\n" +
          "Se o usu√°rio pedir ajuda ou fizer alguma pergunta sobre como usar o sistema, explique de forma descontra√≠da que ele precisa enviar um link do YouTube para voc√™ converter em MP3. \n\n" +
          "Importante: N√ÉO finja ter encontrado uma URL quando n√£o h√° nenhuma. Apenas oriente o usu√°rio a enviar um link v√°lido do YouTube. Nunca diga 'Encontrei uma URL' se n√£o houver link do YouTube na mensagem. \n\n" +
          "Se o usu√°rio enviar uma sauda√ß√£o simples como 'ol√°', 'oi', responda de forma animada e explique que voc√™ pode converter v√≠deos do YouTube em MP3. \n\n" +
          "Use uma linguagem bem descontra√≠da como se fosse um jovem brasileiro conversando com amigos."
        },
        {
          role: "user",
          content: text
        }
      ],
      model: "llama3-8b-8192",
      temperature: 0.7,
      max_tokens: 1000
    });

    return completion.choices[0].message.content;
  } catch (error) {
    console.error('Erro ao analisar mensagem com Groq:', error);
    return 'Eita, deu ruim! üòÖ Tive um probleminha t√©cnico aqui. Manda de novo a√≠, por favor?';
  }
}

// Extrair URL do YouTube da mensagem
function extractYoutubeUrl(text) {
  // Regex mais rigorosa para evitar falsos positivos
  const urlRegex = /(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)[a-zA-Z0-9_-]+([^\s]*)/;
  const match = text.match(urlRegex);
  
  // Verifica√ß√£o adicional para confirmar que √© realmente uma URL do YouTube
  if (match && match[0]) {
    const possibleUrl = match[0];
    // Verificar se a URL cont√©m pelo menos um dom√≠nio do YouTube
    if (possibleUrl.includes('youtube.com') || possibleUrl.includes('youtu.be')) {
      console.log('URL do YouTube detectada:', possibleUrl);
      return possibleUrl;
    }
  }
  
  return null;
}

// Obter informa√ß√µes do v√≠deo
async function getVideoInfo(url) {
  try {
    const info = await ytDlp(url, {
      dumpSingleJson: true,
      noCheckCertificate: true,
      noWarnings: true,
      preferFreeFormats: true,
      addHeader: [
        'referer:youtube.com',
        'user-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      ]
    });
    
    // Verificar o tamanho do arquivo
    if (info.filesize_approx > MAX_FILE_SIZE_MB * 1024 * 1024) {
      throw new Error(`O arquivo √© muito grande (${Math.round(info.filesize_approx / (1024 * 1024))}MB). O limite √© ${MAX_FILE_SIZE_MB}MB.`);
    }
    
    return {
      title: info.title,
      id: extractVideoId(url),
      duration: info.duration,
      filesize: info.filesize_approx
    };
  } catch (error) {
    console.error('Erro ao obter informa√ß√µes do v√≠deo:', error);
    throw error;
  }
}

// Exibir mensagem de ajuda
function getHelpMessage() {
  return `üî• *Bot YouTube pra MP3* üéµ

*Como usar, √© mam√£o com a√ß√∫car:*
1Ô∏è‚É£ Manda o link do YouTube a√≠ (v√≠deo ou playlist)
2Ô∏è‚É£ Relaxa que t√¥ processando...
3Ô∏è‚É£ Pega teu MP3 na hora! ü§ô

*Comandos top:*
‚Ä¢ !ajuda - Te explico tudo de novo
‚Ä¢ !stats - Mostra as estat√≠sticas (s√≥ pros admin)
‚Ä¢ !assinar - Informa√ß√µes sobre a assinatura premium
‚Ä¢ !pix - Gera um QR Code para pagamento via PIX
‚Ä¢ !verificar - Verifica o status do seu pagamento
‚Ä¢ !status - Veja o status da sua assinatura

*Plano Premium - Apenas R$${SUBSCRIPTION_PRICE}/m√™s:*
‚Ä¢ Downloads ilimitados üöÄ
‚Ä¢ Suporte a playlists (at√© ${MAX_PLAYLIST_ITEMS} v√≠deos) üéß
‚Ä¢ Prioridade no processamento ‚ö°
‚Ä¢ Suporte personalizado üëë

*Plano Gratuito:*
‚Ä¢ 5 convers√µes por dia
‚Ä¢ M√°ximo 2 v√≠deos por playlist

*Limita√ß√µes (√© o jeito, n√©):*
‚Ä¢ Arquivo at√© ${MAX_FILE_SIZE_MB}MB (culpa do WhatsApp üôÑ)
‚Ä¢ M√°ximo ${MAX_PLAYLIST_ITEMS} v√≠deos por playlist

Feito com Groq, t√° voando! üöÄ`;
}

// Obter estat√≠sticas de uso
function getStatsMessage() {
  return `üìä *Estat√≠sticas do Bot - T√° bombando!* üî•

‚Ä¢ Convers√µes: ${stats.totalConversions} (t√° voando! üöÄ)
‚Ä¢ Galera usando: ${stats.totalUsers.size} pessoas
‚Ä¢ Bugs: ${stats.errors} (at√© que t√¥ aguentando bem üòé)
‚Ä¢ √öltimo erro: ${stats.lastError || 'Zero! Tamo bem demais'}

*Pagamentos:*
‚Ä¢ Total de pagamentos: ${stats.payments.total}
‚Ä¢ Pagamentos aprovados: ${stats.payments.successful}
‚Ä¢ Pagamentos falhos: ${stats.payments.failed}
‚Ä¢ Taxa de aprova√ß√£o: ${stats.payments.total > 0 ? Math.round((stats.payments.successful / stats.payments.total) * 100) : 0}%

*Galera que mais usa:*
${Object.entries(stats.userUsage)
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5)
  .map(([number, count], index) => {
    // Formata o n√∫mero para exibi√ß√£o
    const formattedNumber = number.includes('@') 
      ? `${number.split('@')[0].slice(-4)}` 
      : `${number.slice(-4)}`;
    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
    const isPremium = hasActiveSubscription(number) ? ' üíé' : '';
    return `${medal} ${formattedNumber}${isPremium}: ${count} convers√µes`;
  })
  .join('\n')}`;
}

// Fun√ß√£o para obter informa√ß√µes de assinatura
function getSubscriptionMessage() {
  return `üíé *Assinatura Premium - R$${SUBSCRIPTION_PRICE}/m√™s* üíé

Com nosso plano premium, voc√™ pode:
‚Ä¢ Converter quantos v√≠deos quiser, sem limites! üöÄ
‚Ä¢ Baixar playlists inteiras de uma vez! üéß
‚Ä¢ Prioridade no processamento! ‚è±Ô∏è
‚Ä¢ Atendimento VIP! üëë

Para assinar, √© super simples:
1Ô∏è‚É£ Digite !pix para gerar um QR Code de pagamento
2Ô∏è‚É£ Pague o valor de R$${SUBSCRIPTION_PRICE} usando o PIX
3Ô∏è‚É£ Sua assinatura ser√° ativada automaticamente!

Sua assinatura ficar√° ativa por 30 dias ap√≥s a confirma√ß√£o do pagamento! üîì

D√∫vidas? S√≥ mandar !ajuda que te respondo rapidinho! üòâ`;
}

// Gerar QR Code PIX usando Mercado Pago
async function generatePixQRCode(userId, messageObj = null) {
  try {
    // Verificar se o token est√° configurado
    if (!process.env.MERCADOPAGO_ACCESS_TOKEN) {
      throw new Error("Token de acesso do Mercado Pago n√£o configurado");
    }
    
    // Log para debug
    console.log("Tentando criar pagamento PIX com Mercado Pago...");
    
    // Gerar ID de refer√™ncia √∫nico para este pagamento
    const paymentId = `BOT_${userId}_${Date.now()}`;
    
    // Configurar detalhes do pagamento conforme documenta√ß√£o atual
    const payment_data = {
      transaction_amount: SUBSCRIPTION_PRICE,
      description: process.env.PIX_DESCRIPTION || "Assinatura Premium do Bot YouTube MP3",
      payment_method_id: "pix",
      payer: {
        email: "cliente@exemplo.com",
        first_name: "Usuario",
        last_name: "WhatsApp",
        identification: {
          type: "CPF",
          number: "19119119100"
        }
      },
      external_reference: paymentId
    };
    
    console.log("Dados do pagamento:", JSON.stringify(payment_data));
    
    try {
      // Criar pagamento no Mercado Pago
      const payment = await paymentClient.create({ body: payment_data });
      
      console.log("Resposta do Mercado Pago:", JSON.stringify(payment));
      
      // Tentar encontrar as informa√ß√µes do QR code em diferentes locais poss√≠veis na resposta
      let qrCode, qrCodeText, paymentResponseId;
      
      console.log("Estrutura da resposta:", Object.keys(payment).join(", "));
      
      // Imprimir a resposta completa para depura√ß√£o
      console.log("Resposta completa:", JSON.stringify(payment, null, 2));
      
      // Nova abordagem para extrair os dados do QR code
      // Para SDK 2.3.0, verifica se os dados est√£o diretamente no objeto payment
      if (payment.id) {
        paymentResponseId = payment.id;
        
        // Verificar se os dados do ponto de intera√ß√£o est√£o dispon√≠veis diretamente
        if (payment.point_of_interaction && payment.point_of_interaction.transaction_data) {
          console.log("Extraindo dados diretamente do objeto payment");
          qrCode = payment.point_of_interaction.transaction_data.qr_code_base64;
          qrCodeText = payment.point_of_interaction.transaction_data.qr_code;
        }
      }
      
      // Abordagem de fallback para vers√µes anteriores do SDK
      if (!paymentResponseId || !qrCodeText) {
        // Verificar estrutura aninhada em response
        if (payment.response) {
          paymentResponseId = paymentResponseId || payment.response.id;
          console.log("point_of_interaction existe?", !!payment.response.point_of_interaction);
          
          if (payment.response.point_of_interaction && 
              payment.response.point_of_interaction.transaction_data) {
            console.log("transaction_data existe?", !!payment.response.point_of_interaction.transaction_data);
            console.log("Campos em transaction_data:", Object.keys(payment.response.point_of_interaction.transaction_data).join(", "));
            
            qrCode = qrCode || payment.response.point_of_interaction.transaction_data.qr_code_base64;
            qrCodeText = qrCodeText || payment.response.point_of_interaction.transaction_data.qr_code;
          } 
          // Se n√£o encontrou no caminho esperado, tente outros caminhos poss√≠veis
          else if (payment.response.transaction_details && 
                  payment.response.transaction_details.external_resource_url) {
            qrCodeText = qrCodeText || payment.response.transaction_details.external_resource_url;
          }
        } 
        // Verificar estrutura de data (outro formato poss√≠vel)
        else if (payment.data) {
          paymentResponseId = paymentResponseId || payment.data.id;
          
          if (payment.data.point_of_interaction && 
              payment.data.point_of_interaction.transaction_data) {
            qrCode = qrCode || payment.data.point_of_interaction.transaction_data.qr_code_base64;
            qrCodeText = qrCodeText || payment.data.point_of_interaction.transaction_data.qr_code;
          }
        }
      }
      
      // Se ainda n√£o encontrou, tente procurar em toda a estrutura usando busca recursiva
      if (!qrCodeText || !qrCode) {
        console.log("Procurando QR code em toda a estrutura usando busca recursiva...");
        // Fun√ß√£o para procurar recursivamente na estrutura de resposta
        function findInObject(obj, key) {
          if (!obj || typeof obj !== 'object') return null;
          
          if (obj[key]) return obj[key];
          
          for (const k in obj) {
            if (typeof obj[k] === 'object') {
              const found = findInObject(obj[k], key);
              if (found) return found;
            }
          }
          
          return null;
        }
        
        qrCodeText = findInObject(payment, 'qr_code') || findInObject(payment, 'ticket_url');
        qrCode = findInObject(payment, 'qr_code_base64');
      }
      
      if (!paymentResponseId) {
        console.warn("‚ö†Ô∏è ID do pagamento n√£o encontrado na resposta, mas continuando em modo de desenvolvimento...");
        // Em vez de lan√ßar um erro, vamos continuar apenas em modo de desenvolvimento
        if (process.env.NODE_ENV !== 'development') {
          throw new Error("ID do pagamento n√£o encontrado na resposta");
        }
        paymentResponseId = "DEV_" + Date.now();
      }
      
      if (!qrCodeText) {
        console.warn("‚ö†Ô∏è QR Code do PIX n√£o encontrado na resposta, mas continuando em modo de desenvolvimento...");
        // Em vez de lan√ßar um erro, vamos continuar apenas em modo de desenvolvimento
        if (process.env.NODE_ENV !== 'development') {
          throw new Error("QR Code do PIX n√£o encontrado na resposta");
        }
        qrCodeText = "PIX_SIMULADO_" + Date.now();
      }
      
      console.log("Pagamento criado com sucesso, ID:", paymentResponseId);

      // No desenvolvimento, se n√£o tivermos os dados completos, vamos ativar diretamente a assinatura
      if (process.env.NODE_ENV === 'development' && (!qrCode || !qrCodeText)) {
        console.log("Ativando assinatura diretamente em modo de desenvolvimento");
        const expiryDate = activateSubscription(userId, true);
        
        // Se temos um objeto de mensagem, enviar confirma√ß√£o
        if (messageObj) {
          messageObj.reply(`‚úÖ *Assinatura Premium Ativada em Modo Desenvolvimento* ‚úÖ

Sua assinatura foi ativada automaticamente porque estamos em ambiente de desenvolvimento!

‚Ä¢ V√°lida at√©: ${expiryDate}
‚Ä¢ Status: ATIVO ‚úì

Aproveite todos os recursos premium:
‚Ä¢ Downloads ilimitados
‚Ä¢ Convers√£o de playlists
‚Ä¢ Prioridade no processamento

Nota: Em produ√ß√£o, ser√° necess√°rio o pagamento via PIX.`);
        }
      }
      
      // Armazenar o pagamento pendente para verifica√ß√£o posterior
      pendingPayments[userId] = {
        id: paymentResponseId,
        external_reference: paymentId,
        created_at: new Date(),
        amount: SUBSCRIPTION_PRICE,
        status: "pending"
      };
      
      // Retornar dados do pagamento PIX
      return {
        qrCode: qrCode || "",  // Pode ser vazio se s√≥ tivermos o texto
        qrCodeText: qrCodeText,
        paymentId: paymentResponseId
      };
      
    } catch (mpError) {
      console.error("Erro espec√≠fico do Mercado Pago:", JSON.stringify(mpError, null, 2));
      
      // Tentar extrair informa√ß√µes detalhadas do erro
      let errorDetail = "Erro desconhecido";
      
      if (mpError.cause) {
        console.error("Causa do erro:", JSON.stringify(mpError.cause, null, 2));
      }
      
      if (mpError.response && mpError.response.data) {
        console.error("Detalhes do erro:", JSON.stringify(mpError.response.data, null, 2));
        if (mpError.response.data.message) {
          errorDetail = mpError.response.data.message;
        } else if (mpError.response.data.error) {
          errorDetail = mpError.response.data.error;
        }
      }
      
      // Exibir todas as propriedades do objeto de erro para depura√ß√£o
      console.error("Todas as propriedades do erro:", Object.keys(mpError));
      
      throw new Error(`Erro ao processar pagamento no Mercado Pago: ${errorDetail}`);
    }
  } catch (error) {
    console.error("Erro ao gerar QR Code PIX:", error);
    
    // Mensagem mais detalhada para o desenvolvedor
    if (error.status === 403) {
      console.error("Erro de autoriza√ß√£o: Verifique se seu token do Mercado Pago tem permiss√µes para criar pagamentos.");
      console.error("1. Verifique se est√° usando um token de produ√ß√£o (n√£o de sandbox)");
      console.error("2. Verifique se sua conta est√° habilitada para receber pagamentos via PIX");
      console.error("3. O token precisa ter scope para criar pagamentos");
    }
    
    // Para simplificar durante o desenvolvimento, vamos ativar a assinatura diretamente
    if (process.env.NODE_ENV === 'development') {
      console.log("Modo de desenvolvimento: Ativando assinatura sem pagamento");
      const expiryDate = activateSubscription(userId, true);
      
      // Se temos um objeto de mensagem, enviar confirma√ß√£o
      if (messageObj) {
        messageObj.reply(`‚úÖ *Assinatura Premium Ativada em Modo Desenvolvimento* ‚úÖ

Sua assinatura foi ativada automaticamente porque estamos em ambiente de desenvolvimento!

‚Ä¢ V√°lida at√©: ${expiryDate}
‚Ä¢ Status: ATIVO ‚úì

Aproveite todos os recursos premium:
‚Ä¢ Downloads ilimitados
‚Ä¢ Convers√£o de playlists
‚Ä¢ Prioridade no processamento

Nota: Em produ√ß√£o, ser√° necess√°rio o pagamento via PIX.`);
      }
      
      throw new Error(`Falha ao gerar PIX, mas assinatura ativada no modo de desenvolvimento at√© ${expiryDate}`);
    }
    
    throw error;
  }
}

// Verificar status de um pagamento
async function checkPaymentStatus(paymentId) {
  try {
    const response = await paymentClient.get({ id: paymentId });
    console.log("Resposta do status do pagamento:", JSON.stringify(response, null, 2));
    
    // Compatibilidade com SDK 2.3.0 - tentar diferentes estruturas de resposta
    if (response.status) {
      // Estrutura direta do SDK 2.3.0
      return response.status;
    } else if (response.response && response.response.status) {
      // Estrutura aninhada de vers√µes anteriores
      return response.response.status;
    } else {
      // Se n√£o encontrar o status, tentar buscar em toda a estrutura
      function findInObject(obj, key) {
        if (!obj || typeof obj !== 'object') return null;
        
        if (obj[key]) return obj[key];
        
        for (const k in obj) {
          if (typeof obj[k] === 'object') {
            const found = findInObject(obj[k], key);
            if (found) return found;
          }
        }
        
        return null;
      }
      
      const status = findInObject(response, 'status');
      return status || "unknown";
    }
  } catch (error) {
    console.error("Erro ao verificar status do pagamento:", error);
    return "error";
  }
}

// Verificar pagamentos pendentes periodicamente
async function checkPendingPayments() {
  for (const userId in pendingPayments) {
    const payment = pendingPayments[userId];
    
    // Verificar pagamentos criados h√° menos de 24 horas
    const paymentAge = (new Date() - new Date(payment.created_at)) / (1000 * 60 * 60);
    if (paymentAge < 24 && payment.status === "pending") {
      const status = await checkPaymentStatus(payment.id);
      
      if (status === "approved") {
        // Pagamento aprovado, ativar assinatura
        const expiryDate = activateSubscription(userId);
        pendingPayments[userId].status = "approved";
        stats.payments.successful++;
        
        // Notificar o usu√°rio sobre o pagamento aprovado
        try {
          await client.sendMessage(`${userId}@c.us`, `‚úÖ *Pagamento Aprovado!* ‚úÖ

Recebemos seu pagamento de R$${SUBSCRIPTION_PRICE} e sua assinatura premium foi ativada!

‚Ä¢ V√°lida at√©: ${expiryDate}
‚Ä¢ Status: ATIVO ‚úì

Aproveite todos os recursos premium:
‚Ä¢ Downloads ilimitados
‚Ä¢ Convers√£o de playlists
‚Ä¢ Prioridade no processamento

Obrigado por assinar! üöÄ`);
        } catch (error) {
          console.error("Erro ao notificar usu√°rio sobre pagamento:", error);
        }
        
      } else if (status === "rejected" || status === "cancelled") {
        // Pagamento rejeitado ou cancelado
        pendingPayments[userId].status = status;
        stats.payments.failed++;
        
        // Notificar o usu√°rio sobre o problema
        try {
          await client.sendMessage(`${userId}@c.us`, `‚ùå *Pagamento ${status === "rejected" ? "Rejeitado" : "Cancelado"}* ‚ùå

Infelizmente seu pagamento n√£o foi conclu√≠do.

Voc√™ pode tentar novamente digitando !pix para gerar um novo QR code.

Precisa de ajuda? Digite !ajuda para falar com um administrador.`);
        } catch (error) {
          console.error("Erro ao notificar usu√°rio sobre pagamento:", error);
        }
      }
    }
  }

  // Limpar pagamentos antigos (mais de 24h)
  for (const userId in pendingPayments) {
    const payment = pendingPayments[userId];
    const paymentAge = (new Date() - new Date(payment.created_at)) / (1000 * 60 * 60);
    if (paymentAge >= 24) {
      delete pendingPayments[userId];
    }
  }
}

// Verificar pagamentos a cada 5 minutos
setInterval(checkPendingPayments, 5 * 60 * 1000);

// Evento de mensagem
client.on('message', async (message) => {
  try {
    const text = message.body;
    const sender = message.from;
    const normalizedSender = normalizePhoneNumber(sender);
    
    console.log(`Mensagem recebida de ${sender} (normalizado: ${normalizedSender}): ${text}`);
    
    // Verificar se √© uma primeira mensagem (sauda√ß√£o)
    const isSaudacao = /^(oi|ol√°|ola|bom dia|boa tarde|boa noite|eae|e ai|salve|fala|al√¥|alo|hi|hello|hey|start|comecar|come√ßar|iniciar)[\s!?.]*$/i.test(text);
    
    if (isSaudacao) {
      const hora = new Date().getHours();
      let saudacao = '';
      
      if (hora >= 5 && hora < 12) {
        saudacao = 'Bom dia';
      } else if (hora >= 12 && hora < 18) {
        saudacao = 'Boa tarde';
      } else {
        saudacao = 'Boa noite';
      }
      
      const mensagemInicial = `${saudacao}, beleza? ü§ô T√¥ aqui pra te ajudar a baixar √°udios do YouTube! üéµ

Manda a√≠ o link do v√≠deo que voc√™ quer converter pra MP3! üî•

Se precisar de uma ajudinha, s√≥ mandar "!ajuda" que te explico melhor! üòâ`;
      
      await message.reply(mensagemInicial);
      return;
    }
    
    // Registrar o usu√°rio nas estat√≠sticas
    stats.totalUsers.add(normalizedSender);
    if (!stats.userUsage[normalizedSender]) {
      stats.userUsage[normalizedSender] = 0;
    }
    
    // Comandos especiais - Processar antes da an√°lise da IA
    // Comando de ajuda
    if (text === '!ajuda' || text.toLowerCase() === 'ajuda' || text.toLowerCase() === 'help') {
      await message.reply(getHelpMessage());
      return;
    }
    
    // Comando de estat√≠sticas
    if (text === '!stats') {
      console.log(`Comando de estat√≠sticas recebido de ${normalizedSender}`);
      console.log(`Administradores configurados: ${adminNumbers.join(', ')}`);
      
      const isAdmin = adminNumbers.some(admin => normalizedSender.includes(admin) || admin.includes(normalizedSender));
      
      if (isAdmin) {
        console.log(`Usu√°rio ${normalizedSender} autorizado como administrador`);
        await message.reply(getStatsMessage());
      } else {
        console.log(`Usu√°rio ${normalizedSender} n√£o autorizado como administrador`);
        await message.reply('‚õî Acesso negado, mano! S√≥ os admin podem ver isso... üòú');
      }
      return;
    }
    
    // Comando para informa√ß√µes sobre assinatura
    if (text === '!assinar' || text.toLowerCase() === 'assinar') {
      await message.reply(getSubscriptionMessage());
      return;
    }
    
    // Comando para simular pagamento (TEMPOR√ÅRIO - apenas para desenvolvimento)
    if (text === '!simular_pagamento') {
      // Verificar se o usu√°rio √© um administrador ou se estamos em ambiente de desenvolvimento
      const isAdmin = adminNumbers.some(admin => normalizedSender.includes(admin) || admin.includes(normalizedSender));
      
      if (isAdmin || process.env.NODE_ENV === 'development') {
        const expiryDate = activateSubscription(normalizedSender);
        await message.reply(`‚úÖ *MODO DESENVOLVIMENTO* ‚úÖ\n\nAssinatura ativada para teste at√© ${expiryDate}. Esta fun√ß√£o √© apenas para desenvolvimento.`);
        return;
      } else {
        await message.reply('‚õî Este comando s√≥ est√° dispon√≠vel para administradores ou em ambiente de desenvolvimento.');
        return;
      }
    }
    
    // Comando para gerar PIX
    if (text === '!pix') {
      try {
        await message.reply('‚è≥ Gerando QR Code PIX para assinatura...');
        
        // Se estivermos em modo de desenvolvimento e houver erro no Mercado Pago, ofere√ßa a op√ß√£o de simular pagamento
        if (process.env.NODE_ENV === 'development') {
          try {
            const pixData = await generatePixQRCode(normalizedSender, message);
            
            try {
              // Tentar gerar imagem do QR Code e enviar
              if (pixData.qrCode) {
                const qrBuffer = Buffer.from(pixData.qrCode, 'base64');
                fs.writeFileSync(path.join(tempDir, `pix_${normalizedSender}.png`), qrBuffer);
                
                const media = MessageMedia.fromFilePath(path.join(tempDir, `pix_${normalizedSender}.png`));
                
                await message.reply(media, undefined, { 
                  caption: `üîí *Assinatura Premium - R$${SUBSCRIPTION_PRICE}/m√™s* üîí

Escaneie o QR Code acima para fazer o pagamento via PIX.

Ou copie o c√≥digo PIX abaixo:
\`\`\`${pixData.qrCodeText}\`\`\`

Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente em at√© 5 minutos!

ID do Pagamento: ${pixData.paymentId}` 
                });
                
                // Limpar o arquivo tempor√°rio
                fs.unlinkSync(path.join(tempDir, `pix_${normalizedSender}.png`));
              } else {
                // Se n√£o tiver QR code em base64, enviar s√≥ o texto
                await message.reply(`üîí *Assinatura Premium - R$${SUBSCRIPTION_PRICE}/m√™s* üîí

Copie o c√≥digo PIX abaixo para fazer o pagamento:
\`\`\`${pixData.qrCodeText}\`\`\`

Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente em at√© 5 minutos!

ID do Pagamento: ${pixData.paymentId}`);
              }
              
              stats.payments.total++;
              
            } catch (imageError) {
              console.error('Erro ao gerar imagem do QR code:', imageError);
              
              // Enviar apenas o texto do PIX caso a gera√ß√£o de imagem falhe
              await message.reply(`üîí *Assinatura Premium - R$${SUBSCRIPTION_PRICE}/m√™s* üîí

N√£o foi poss√≠vel gerar a imagem QR Code, mas voc√™ pode copiar o c√≥digo PIX abaixo:
\`\`\`${pixData.qrCodeText}\`\`\`

Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente em at√© 5 minutos!

ID do Pagamento: ${pixData.paymentId}`);
              
              stats.payments.total++;
            }
          } catch (error) {
            console.error('Erro ao gerar PIX:', error);
            await message.reply(`‚ùå N√£o foi poss√≠vel gerar o QR Code PIX. Erro: ${error.message}\n\nEstamos em ambiente de desenvolvimento, voc√™ pode digitar !simular_pagamento para ativar a assinatura para testes.`);
            return;
          }
        } else {
          try {
            const pixData = await generatePixQRCode(normalizedSender, message);
            
            // Gerar imagem do QR Code e enviar
            const qrBuffer = Buffer.from(pixData.qrCode, 'base64');
            fs.writeFileSync(path.join(tempDir, `pix_${normalizedSender}.png`), qrBuffer);
            
            const media = MessageMedia.fromFilePath(path.join(tempDir, `pix_${normalizedSender}.png`));
            
            await message.reply(media, undefined, { 
              caption: `üîí *Assinatura Premium - R$${SUBSCRIPTION_PRICE}/m√™s* üîí

Escaneie o QR Code acima para fazer o pagamento via PIX.

Ou copie o c√≥digo PIX abaixo:
\`\`\`${pixData.qrCodeText}\`\`\`

Ap√≥s o pagamento, sua assinatura ser√° ativada automaticamente em at√© 5 minutos!

ID do Pagamento: ${pixData.paymentId}` 
            });
            
            // Limpar o arquivo tempor√°rio
            fs.unlinkSync(path.join(tempDir, `pix_${normalizedSender}.png`));
            
            stats.payments.total++;
            
          } catch (error) {
            console.error('Erro ao gerar PIX:', error);
            await message.reply('‚ùå N√£o foi poss√≠vel gerar o QR Code PIX. Por favor, tente novamente mais tarde ou entre em contato com o administrador.');
            return;
          }
        }
      } catch (error) {
        console.error('Erro ao gerar PIX:', error);
        await message.reply('‚ùå N√£o foi poss√≠vel gerar o QR Code PIX. Por favor, tente novamente mais tarde ou entre em contato com o administrador.');
      }
      return;
    }
    
    // Comando para verificar pagamento manualmente
    if (text === '!verificar') {
      if (pendingPayments[normalizedSender]) {
        await message.reply('‚è≥ Verificando seu pagamento...');
        
        const paymentId = pendingPayments[normalizedSender].id;
        const status = await checkPaymentStatus(paymentId);
        
        if (status === "approved") {
          // Pagamento aprovado, ativar assinatura
          const expiryDate = activateSubscription(normalizedSender);
          pendingPayments[normalizedSender].status = "approved";
          stats.payments.successful++;
          
          await message.reply(`‚úÖ *Pagamento Aprovado!* ‚úÖ

Recebemos seu pagamento de R$${SUBSCRIPTION_PRICE} e sua assinatura premium foi ativada!

‚Ä¢ V√°lida at√©: ${expiryDate}
‚Ä¢ Status: ATIVO ‚úì

Aproveite todos os recursos premium:
‚Ä¢ Downloads ilimitados
‚Ä¢ Convers√£o de playlists
‚Ä¢ Prioridade no processamento

Obrigado por assinar! üöÄ`);
          
        } else if (status === "pending") {
          await message.reply(`‚è≥ *Pagamento Pendente* ‚è≥

Ainda n√£o recebemos a confirma√ß√£o do seu pagamento.

Se voc√™ j√° pagou, aguarde alguns minutos para o processamento.
O sistema verifica automaticamente a cada 5 minutos.

ID do Pagamento: ${paymentId}`);
          
        } else {
          await message.reply(`‚ùå *Pagamento ${status === "rejected" ? "Rejeitado" : "Cancelado/Falhou"}* ‚ùå

Infelizmente seu pagamento n√£o foi conclu√≠do.

Voc√™ pode tentar novamente digitando !pix para gerar um novo QR code.

Precisa de ajuda? Digite !ajuda para falar com um administrador.`);
        }
      } else {
        await message.reply('‚ùì *Nenhum pagamento pendente encontrado* ‚ùì\n\nDigite !pix para gerar um novo c√≥digo de pagamento.');
      }
      return;
    }
    
    // Se a mensagem cont√©m uma URL do YouTube, converter diretamente
    const youtubeUrl = extractYoutubeUrl(text);
    
    if (youtubeUrl) {
      // Verifica√ß√£o final para garantir que √© uma URL v√°lida do YouTube
      if (!youtubeUrl.includes('youtube.com/watch?v=') && !youtubeUrl.includes('youtu.be/')) {
        console.log('URL detectada, mas n√£o parece ser um v√≠deo do YouTube v√°lido:', youtubeUrl);
        // N√£o √© uma URL de v√≠deo v√°lida, vamos usar a IA para responder
        const analysis = await analyzeMessage(text);
        await message.reply(analysis);
        return;
      }
       
      // Verificar limite de uso - apenas se n√£o tem assinatura e j√° usou no dia de hoje
      const isSubscriber = hasActiveSubscription(normalizedSender);
      
      // Verificar se o usu√°rio j√° usou o servi√ßo hoje e informar sobre sua assinatura
      if (isSubscriber) {
        await message.reply(`üíé *Usu√°rio Premium Detectado!* üíé
Sua assinatura est√° ativa. Aproveite convers√µes ilimitadas! üöÄ`);
      } else {
        // Verificar limites di√°rios para usu√°rios gratuitos (5 convers√µes por dia)
        const today = new Date().toLocaleDateString();
        if (!stats.dailyUsage) {
          stats.dailyUsage = {};
        }
        
        if (!stats.dailyUsage[today]) {
          stats.dailyUsage[today] = {};
        }
        
        if (!stats.dailyUsage[today][normalizedSender]) {
          stats.dailyUsage[today][normalizedSender] = 0;
        }
        
        // Mostrar quantidade de convers√µes restantes
        const usedToday = stats.dailyUsage[today][normalizedSender];
        const remainingToday = 5 - usedToday;
        
        await message.reply(`üìä *Modo Gratuito* üìä
Voc√™ tem ${remainingToday} convers√µes restantes hoje.

üí° Quer convers√µes ilimitadas? Digite !assinar`);
        
        if (usedToday >= 5) {
          await message.reply(`üîí *Limite di√°rio atingido!* üîí

Voc√™ j√° converteu 5 v√≠deos hoje, que √© o limite do plano gratuito.

Quer converter mais? Assine nosso plano premium por apenas R$${SUBSCRIPTION_PRICE}/m√™s e tenha:
‚Ä¢ Convers√µes ilimitadas üöÄ
‚Ä¢ Acesso a playlists completas üéß
‚Ä¢ E muito mais!

Digite !assinar para saber como come√ßar! üíé`);
          return;
        }
        
        stats.dailyUsage[today][normalizedSender]++;
      }
      
      try {
        // Verificar se √© uma playlist
        if (isPlaylistUrl(youtubeUrl)) {
          // Se n√£o tem assinatura, limitar a 2 v√≠deos da playlist
          const maxVideos = hasActiveSubscription(normalizedSender) ? MAX_PLAYLIST_ITEMS : 2;
          
          if (!hasActiveSubscription(normalizedSender)) {
            await message.reply(`üîÑ Playlist detectada! No plano gratuito voc√™ pode baixar at√© 2 v√≠deos. 
            
üí° Para baixar playlists completas, assine o plano premium por apenas R$${SUBSCRIPTION_PRICE}/m√™s! Digite !assinar para saber mais.`);
          } else {
            await message.reply(`üî• Playlist detectada! Vou baixar at√© ${MAX_PLAYLIST_ITEMS} v√≠deos pra voc√™. J√° t√¥ no corre, aguenta a√≠... ‚è≥`);
          }
          
          const playlistInfo = await getPlaylistInfo(youtubeUrl);
          
          // Limitar o n√∫mero de v√≠deos para usu√°rios gratuitos
          const entries = hasActiveSubscription(normalizedSender) 
            ? playlistInfo.entries.slice(0, MAX_PLAYLIST_ITEMS) 
            : playlistInfo.entries.slice(0, 2);
          
          await message.reply(`üìã Playlist: *${playlistInfo.title}*\nüìä Baixando ${entries.length} de ${playlistInfo.playlist_count} v√≠deos${hasActiveSubscription(normalizedSender) ? '' : ' (limite do plano gratuito)'}, tamo junto! üí™`);
          
          // Processar cada v√≠deo da playlist
          for (let i = 0; i < entries.length; i++) {
            const video = entries[i];
            const videoUrl = `https://www.youtube.com/watch?v=${video.id}`;
            
            try {
              await message.reply(`‚è≥ Processando v√≠deo ${i+1}/${entries.length}: ${video.title}`);
              
              const outputPath = path.join(tempDir, `${video.id}.mp3`);
              
              // Converter o v√≠deo para MP3
              await convertYoutubeToMp3(videoUrl, outputPath);
              
              // Verificar se o arquivo existe e n√£o √© muito grande
              if (fs.existsSync(outputPath)) {
                const fileStats = fs.statSync(outputPath);
                if (fileStats.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                  await message.reply(`‚ö†Ô∏è Caramba, o arquivo de "${video.title}" ficou grande demais (${Math.round(fileStats.size / (1024 * 1024))}MB). O WhatsApp √© fresco, n√£o aceita. ü§¶‚Äç‚ôÇÔ∏è`);
                  fs.unlinkSync(outputPath);
                  continue;
                }
                
                // Enviar o arquivo MP3
                const media = MessageMedia.fromFilePath(outputPath);
                await message.reply(media, undefined, { caption: `üéß *${video.title}*\n\nT√° na m√£o! üî•` });
                
                // Limpar o arquivo tempor√°rio
                fs.unlinkSync(outputPath);
                
                // Atualizar estat√≠sticas
                stats.totalConversions++;
                stats.userUsage[normalizedSender]++;
              }
            } catch (error) {
              console.error(`Erro ao processar v√≠deo ${video.id} da playlist:`, error);
              await message.reply(`‚ùå Deu ruim no v√≠deo ${i+1}: "${video.title}". Vou tentar o pr√≥ximo! üèÉ‚Äç‚ôÇÔ∏è`);
              
              // Registrar o erro
              stats.errors++;
              stats.lastError = `Playlist item ${i+1}: ${error.message}`;
            }
          }
          
          await message.reply('‚úÖ Playlist conclu√≠da! T√° tudo a√≠, aproveita! üéß');
        } else {
          // Processar v√≠deo √∫nico
          await message.reply('‚è≥ J√° t√¥ convertendo seu v√≠deo, coisa linda! S√≥ um minutinho...');
          
          // Obter informa√ß√µes do v√≠deo
          const videoInfo = await getVideoInfo(youtubeUrl);
          const videoTitle = videoInfo.title.replace(/[^\w\s]/gi, '');
          const videoId = videoInfo.id;
          
          // Verificar dura√ß√£o do v√≠deo
          if (videoInfo.duration > 1800) { // 30 minutos
            await message.reply('‚ö†Ô∏è Eita, esse v√≠deo √© grand√£o! (mais de 30 minutos) Vou tentar, mas se der ruim n√£o me xinga, t√°? üòÖ');
          }
          
          const outputPath = path.join(tempDir, `${videoId}.mp3`);
          
          // Converter o v√≠deo para MP3
          await convertYoutubeToMp3(youtubeUrl, outputPath);
          
          // Verificar o tamanho do arquivo final
          const fileStats = fs.statSync(outputPath);
          if (fileStats.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
            throw new Error(`O arquivo ficou gigante (${Math.round(fileStats.size / (1024 * 1024))}MB)! WhatsApp n√£o vai aguentar, o limite √© ${MAX_FILE_SIZE_MB}MB. Tenta um v√≠deo menor a√≠! üòâ`);
          }
          
          // Enviar o arquivo MP3
          const media = MessageMedia.fromFilePath(outputPath);
          await message.reply(media, undefined, { caption: `üî• *${videoTitle}*\n\nT√° na m√£o! Curte a√≠! üéß` });
          
          // Limpar o arquivo tempor√°rio
          fs.unlinkSync(outputPath);
          
          // Atualizar estat√≠sticas
          stats.totalConversions++;
          stats.userUsage[normalizedSender]++;
        }
      } catch (error) {
        console.error('Erro ao processar o v√≠deo:', error);
        
        // Mensagem de erro mais amig√°vel e informativa
        let errorMsg = '‚ùå Putz, deu ruim! ';
        
        if (error.message.includes('tamanho') || error.message.includes('grande')) {
          errorMsg += 'Arquivo muito grande pro WhatsApp aguentar. O bicho √© fraco! üòÖ';
        } else if (error.message.includes('Copyright') || error.message.includes('copyright')) {
          errorMsg += 'Esse v√≠deo t√° com copyright, os caras n√£o deixam baixar. üö´';
        } else {
          errorMsg += 'N√£o consegui converter. Manda outro link a√≠, esse t√° osso! ü§î';
        }
        
        await message.reply(errorMsg);
        
        // Registrar o erro
        stats.errors++;
        stats.lastError = error.message;
      }
    } else {
      // Se n√£o houver URL, usar a IA da Groq para entender a inten√ß√£o
      const analysis = await analyzeMessage(text);
      
      // Verificar se a an√°lise encontrou uma URL
      const urlFromAnalysis = extractYoutubeUrl(analysis);
      
      if (urlFromAnalysis) {
        // Verifica√ß√£o adicional para garantir que n√£o √© um falso positivo
        // Se o link n√£o tiver sido enviado pelo usu√°rio, n√£o tentar processar
        if (!text.includes(urlFromAnalysis) && 
            !text.includes('youtube.com') && 
            !text.includes('youtu.be')) {
          console.log('URL encontrada na an√°lise, mas n√£o estava na mensagem original do usu√°rio:', urlFromAnalysis);
          await message.reply(analysis);
          return;
        }
        
        // Se a IA encontrou uma URL, process√°-la
        try {
          await message.reply('‚è≥ Achei um link do YouTube na sua mensagem! J√° t√¥ pegando pra voc√™... üöÄ');
          
          // Verificar se √© uma playlist
          if (isPlaylistUrl(urlFromAnalysis)) {
            await message.reply(`üî• Playlist detectada! Vou baixar at√© ${MAX_PLAYLIST_ITEMS} v√≠deos pra voc√™. J√° t√¥ no corre, aguenta a√≠... ‚è≥`);
            
            const playlistInfo = await getPlaylistInfo(urlFromAnalysis);
            await message.reply(`üìã Playlist: *${playlistInfo.title}*\nüìä Baixando ${playlistInfo.entries.length} de ${playlistInfo.playlist_count} v√≠deos, tamo junto! üí™`);
            
            // Processar cada v√≠deo da playlist
            for (let i = 0; i < playlistInfo.entries.length; i++) {
              const video = playlistInfo.entries[i];
              const videoUrl = `https://www.youtube.com/watch?v=${video.id}`;
              
              try {
                await message.reply(`‚è≥ Processando v√≠deo ${i+1}/${playlistInfo.entries.length}: ${video.title}`);
                
                const outputPath = path.join(tempDir, `${video.id}.mp3`);
                
                // Converter o v√≠deo para MP3
                await convertYoutubeToMp3(videoUrl, outputPath);
                
                // Verificar se o arquivo existe e n√£o √© muito grande
                if (fs.existsSync(outputPath)) {
                  const fileStats = fs.statSync(outputPath);
                  if (fileStats.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                    await message.reply(`‚ö†Ô∏è Caramba, o arquivo de "${video.title}" ficou grande demais (${Math.round(fileStats.size / (1024 * 1024))}MB). O WhatsApp √© fresco, n√£o aceita. ü§¶‚Äç‚ôÇÔ∏è`);
                    fs.unlinkSync(outputPath);
                    continue;
                  }
                  
                  // Enviar o arquivo MP3
                  const media = MessageMedia.fromFilePath(outputPath);
                  await message.reply(media, undefined, { caption: `üéß *${video.title}*\n\nT√° na m√£o! üî•` });
                  
                  // Limpar o arquivo tempor√°rio
                  fs.unlinkSync(outputPath);
                  
                  // Atualizar estat√≠sticas
                  stats.totalConversions++;
                  stats.userUsage[normalizedSender]++;
                }
              } catch (error) {
                console.error(`Erro ao processar v√≠deo ${video.id} da playlist:`, error);
                await message.reply(`‚ùå Deu ruim no v√≠deo ${i+1}: "${video.title}". Vou tentar o pr√≥ximo! üèÉ‚Äç‚ôÇÔ∏è`);
                
                // Registrar o erro
                stats.errors++;
                stats.lastError = `Playlist item ${i+1}: ${error.message}`;
              }
            }
            
            await message.reply('‚úÖ Playlist conclu√≠da! T√° tudo a√≠, aproveita! üéß');
          } else {
            // Processar v√≠deo √∫nico
            await message.reply('‚è≥ J√° t√¥ convertendo seu v√≠deo, coisa linda! S√≥ um minutinho...');
            
            // Obter informa√ß√µes do v√≠deo
            const videoInfo = await getVideoInfo(urlFromAnalysis);
            const videoTitle = videoInfo.title.replace(/[^\w\s]/gi, '');
            const videoId = videoInfo.id;
            
            // Verificar dura√ß√£o do v√≠deo
            if (videoInfo.duration > 1800) { // 30 minutos
              await message.reply('‚ö†Ô∏è Eita, esse v√≠deo √© grand√£o! (mais de 30 minutos) Vou tentar, mas se der ruim n√£o me xinga, t√°? üòÖ');
            }
            
            const outputPath = path.join(tempDir, `${videoId}.mp3`);
            
            await convertYoutubeToMp3(urlFromAnalysis, outputPath);
            
            // Verificar o tamanho do arquivo final
            const fileStats = fs.statSync(outputPath);
            if (fileStats.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
              throw new Error(`O arquivo ficou gigante (${Math.round(fileStats.size / (1024 * 1024))}MB)! WhatsApp n√£o vai aguentar, o limite √© ${MAX_FILE_SIZE_MB}MB. Tenta um v√≠deo menor a√≠! üòâ`);
            }
            
            const media = MessageMedia.fromFilePath(outputPath);
            await message.reply(media, undefined, { caption: `üéµ ${videoTitle}` });
            
            fs.unlinkSync(outputPath);
            
            // Atualizar estat√≠sticas
            stats.totalConversions++;
            stats.userUsage[normalizedSender]++;
          }
        } catch (error) {
          console.error('Erro ao processar o v√≠deo:', error);
          
          // Mensagem de erro mais amig√°vel e informativa
          let errorMsg = '‚ùå Putz, deu ruim! ';
          
          if (error.message.includes('tamanho') || error.message.includes('grande')) {
            errorMsg += 'Arquivo muito grande pro WhatsApp aguentar. O bicho √© fraco! ÔøΩÔøΩ';
          } else if (error.message.includes('Copyright') || error.message.includes('copyright')) {
            errorMsg += 'Esse v√≠deo t√° com copyright, os caras n√£o deixam baixar. üö´';
          } else {
            errorMsg += 'N√£o consegui converter. Manda outro link a√≠, esse t√° osso! ü§î';
          }
          
          await message.reply(errorMsg);
          
          // Registrar o erro
          stats.errors++;
          stats.lastError = error.message;
        }
      } else {
        // Se n√£o encontrou URL, responder com a an√°lise da IA
        await message.reply(analysis);
      }
    } catch (error) {
      console.error('Erro geral ao processar a mensagem:', error);
      
      // Registrar o erro
      stats.errors++;
      stats.lastError = error.message;
      
      // Notificar o usu√°rio
      await message.reply('‚ùå Eita, deu um bug sinistro aqui! üò± Tenta de novo mais tarde ou manda "!ajuda" que eu te explico como me usar direitinho! üòâ');
    }
  });
  
  // Fun√ß√£o para ativar uma assinatura por 30 dias
  function activateSubscription(userId, adminCommand = false) {
    const today = new Date();
    let expiryDate;
    
    // Se j√° tem assinatura, estende por mais 30 dias
    if (subscriptions[userId] && hasActiveSubscription(userId)) {
      expiryDate = new Date(subscriptions[userId].expiresAt);
      expiryDate.setDate(expiryDate.getDate() + 30);
    } else {
      expiryDate = new Date();
      expiryDate.setDate(today.getDate() + 30);
    }
    
    subscriptions[userId] = {
      active: true,
      expiresAt: expiryDate.toISOString(),
      activatedBy: adminCommand ? 'admin' : 'payment',
      activatedAt: today.toISOString()
    };
    
    // Salvar os dados ap√≥s ativa√ß√£o
    saveData();
    
    return expiryDate.toLocaleDateString('pt-BR');
  }
  
  // Iniciar o cliente
  client.initialize();
});